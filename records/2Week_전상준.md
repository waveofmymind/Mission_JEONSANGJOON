# NWeek_OOO.md

## Title: [2Week] 전상준 

### 미션 요구사항 분석 & 체크리스트

---

### N주차 미션 요약

- [ ] 호감 표시에 대한 예외 처리 3가지
  - [ ] 4
  - [ ] 5
  - [ ] 6

- [ ] 네이버 로그인 구현하기

---

**[접근 방법]**

- 호감 표시를 위한 예외 처리를 순차적으로 구현했다.
- 케이스 4: 한 유저가 중복으로 같은 유저에게 호감 표시를 하는 것에 대해서 다음과 같이 접근했다.
  1. 요청시 피호감자와 호감자의 닉네임으로 존재 여부 쿼리를 발생시킨다.
  2. 두가지 파라미터에 대해 중복된 레코드가 있으면 예외를 발생시킨다.
- 케이스 5: 한명의 인스타 회원이 11명 이상의 호감 상대를 등록할 수 없게 하는 것에 대해서는 다음과 같이 접근했다.
  - 호감표시 생성 요청시 현재 인스타 멤버의 호감 표시가 몇명인지 체크할 것
    - 인스타 멤버 필드에 호감 표시 수 필드를 추가할 것인지? -> 선택
    - ~~호감 표시 생성시 카운트 쿼리를 발생시켜 숫자를 셀 것인지?~~
    - ~~로그인하면 호감 표시 수를 캐시에 넣을 것인지?~~
    - **InstaMember에 필드를 추가해서 호감 표시를 할 때마다 증가하도록 구현**
      - 본인만 호감표시를 할 수 있기 때문에 동시성 문제를 고려하지 않아도 된다.

- 케이스 6: 만약 호감 표시를 할때, 피호감자와 호감자가 같더라도 사유가 다르면 수정하도록 설정하기
  - 우선 기존에 중복 호감 표시를 boolean으로 판별만 하던 것을 합쳐서 다시 구현할 필요가 있었다.
  - 중복인 likeablePerson을 조회하고, **사유가 기존과 같을 때에만 예외를 발생시킨다.**

- 네이버 로그인
  - 네이버 로그인은 기존 카카오, 구글 로그인과 응답으로 오는 값이 달랐다.
  - 구글과 카카오는 OAuth2User 객체에서 .getName()으로 고유 코드값을 쉽게 가져올 수 있었지만,
  카카오는 OAuth2User의 attribues 맵에 직접 name이라는 속성이 있었지만, 네이버의 경우는 response 객체에
  모든 정보가 담겨 있었다.
  - 그래서 프로바이더가 네이버인 경우와 그 외의 다른 프로바이더인 경우를 나누어서 oauthId에 값을 넣어야겠다고 생각했다.
  - getAttributes().get("response") 로 response 객체를 뽑아내고, 그것을 다시 맵으로 변환해서 id 속성을 가져올 수 있었다.
**[특이사항]**

- 중복이 존재할때와 존재하지 않을때 새로운 LikeablePerson 객체를 생성해서 저장하는 것을 옵셔널의 ifPresentOrElse를 사용하면 깔끔해질 것이라고 생각했으나,
애로사항이 있었다.
  - 람다 내부에서는 final 변수만 사용할 수 있었다.
  - 또한 람다 내부에서 LikeablePerson을 생성하더라도, return을 사용할 수 없어서 반환시 생성한 LikeablePerson 객체를 넘겨주기 어렵다.

- 네이버 로그인에서 response 객체를 빼내고, oauthId에 넣기 위해 다시 맵으로 형변환을 해서 값을 가져왔다.
  - 강제 형변환을 했기 때문에 이게 옳은 방법인지 잘 모르겠다.
